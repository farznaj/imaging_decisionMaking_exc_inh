% If events are generated by a poisson process at the average rate lambda, 
% then the event time-intervals will have an exponential distribution of mean 1/lambda.
% Therefore, to generate poission events at the rate 5 Hz, I will generate
% an exponentail of inter-event intervals of the mean 1000/5=200ms


needs work : after truncating the dist, the mean gets very different (for most numevents it gets bigger) than the original 1ambda.

eventduration = 10; 
minint = 40; % minimum gap between events (inter-event interval).
doplots = 1;

totstimdur = 1000;
k = 0:totstimdur; % range of intervals (in ms).
maxint = totstimdur-eventduration; 

rngrates = 1:totstimdur/(eventduration+minint);
cols = jet(length(rngrates));
figure; hold on
ii = 0;
for numevents = rngrates
    ii = ii+1;
lambda = numevents/totstimdur; % stimulus rate: 5 events in 1000 ms


% pick random numbers from an exponential distribution
intervals = random('exp',1/lambda-minint, 1,1E6); see if this helps (to subtract minint)

% plot the exponential distribution
if doplots
    n = histc(intervals, k); 
    n = n/sum(n);
    figure; hold on
    plot(k,n,'r')

    % compare it with pdf function.
    plot(pdf('exp',k,1/lambda))
    
end

% truncate the exponential distribution
v = intervals; 
intervals(intervals<minint) = []; 
intervals(intervals>maxint) = [];

int2 = random('exp',1/lambda, 1,1E6);
v2 = int2;
int2(int2<minint) = []; 
int2(int2>maxint) = [];

[nanmean(v2) nanmean(int2) nanmean(v) nanmean(intervals)]

% plot the truncated exponential
if doplots
    n2 = histc(intervals, k); n2 = n2/sum(n2);
    plot(k,n2,'g')
end


%{
%%%%%% now pick random intervals from the truncated distributions.
stimlent = [];
for i=1:1000
stimlen = totstimdur+1;
while stimlen > totstimdur
    allints = intervals(randi(length(intervals), [1,numevents-1]));
    stimlen = sum(allints) + eventduration*(length(allints)+1);
end
stimlent = [stimlent, stimlen];    
end



[n, vec] = hist(stimlent);
n = n/sum(n);
plot(vec, n, 'color', cols(ii,:));

disp(numevents)
%}

pause

end


%% David and Kachi's method for generating events. (it doesn't really end up giving an exponential distribution of inter-event intervals, hence no constant hazard rate.... also the inter-event intervals are still discrete in their method.... )
stimDuration = 1000;
eventDuration = 20;
frames = stimDuration/eventDuration/2;
maxAttempts = 1000;
itot = 1000;
ntr = 0;
rngrate = [6:19];
intervals = NaN(rngrate(end),length(rngrate)*itot);
for thisRate = rngrate
    ntr = ntr+1;
    for itern = 1:itot
        got_it = 0;
        for attempt = 1:maxAttempts
            eventList = [1 (poissrnd(rand, 1, frames-1) > 0)];
            if sum(eventList) == thisRate
                got_it = 1;
                break;
            end
        end
        if ~got_it
            disp('Not enough attempts to generate the required stimulus.');
        end

        i1s = find(eventList==1);
        intervals(1:thisRate, (ntr-1)*itot + itern) = eventDuration + [diff(i1s)-1 0]*(eventDuration*2);
    end
end


%% Plot the distribution of inter-event intervals for Kachi and David's methods.
col = jet(length(rngrate));
vec = min(intervals(:)) : min(intervals(:))*2 : max(intervals(:));
aver = NaN(1,length(rngrate));

figure; hold on
for irate = 1:length(rngrate)
    r = itot*(irate-1)+1:itot*irate;
    n = histc(intervals(:,r), vec);
    na = nanmean(n,2);
    
    aver(irate) = nanmean(nanmean(intervals(:,r)));
    
    plot(vec, na/sum(na), 'color', col(irate,:))
%     pause
end

