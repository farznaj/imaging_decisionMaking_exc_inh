function [framesPerTrial, trialNumbers, frame1RelToStartOff, badAlignTrStartCode, framesPerTrial_galvo] = ...
  framesPerTrialStopStart3An_fn2(binFilename, framecountFilename, headerBug, all_data)
% Farzaneh: use this script for days which have the state
% trial_start_rot_scope. For all previous days use
% framesPerTrialStopStart3An_fn.
%
% [framesPerTrial, trialNumbers, frame1RelToStartOff, badAlignTrStartCode, framesPerTrial_galvo] = ...
%  framesPerTrialStopStart3An_fn2(binFilename, framecountFilename, headerBug, all_data)
%
% This goal of this function is to take two inputs (the analog signal
% acquired alongside the calcium imaging, and the framecounts.txt file
% generated by the script running on the scope) and parse them out to
% identify the frames corresponding to each trial.
%
% Expects a .bin file containing 4 analog channels:
%  AI0: trial codes (encoded as a modified "interleaved 2 of 5" barcode)
%  AI1: slow galvo signal
%  AI2: "trial start" signal (36 ms TTL at start of trial)
%  AI3: dummy channel, not used (but must be present to avoid bug in MScan)
%
% This process is a little complicated, because neither BControl nor MScan
% is totally reliable.
%
% On the BControl side, sometimes the start TTL and trial code seem to be
% missing, but there is an interruption in the slow galvo signal that can
% be used to identify trials that need to be broken up.
%
% On the MScan side, the analog signal and the scanning have no intrinsic
% time alignment signals because of bad design in MScan. It would seem that
% the slow galvo signal should be enough to reconstruct the timing.
% However, the slow galvo signal by itself is not adequate because MScan
% usually drops any final partial frame, but not always (sometimes it
% finishes that partial frame out, and saves it like any other frame). So
% instead we use a combination of the frame counts recorded in
% framecounts.txt and the slow galvo signal; framecounts.txt appears to be
% totally reliable (except when BControl messes up; see above).
%
% Trial numbers are aligned using the "bar codes" that get sent over AI0.
% Rarely, these get lost or are mangled. In those cases, they are usually
% repairable, or can be inferred. If this endangers time alignment, those
% trials are marked as having problematic alignment in badAlignments.
%
% INPUTS
%   binFilename        -- path to the .bin file containing the analog
%                         signals
%   framecountFilename -- path to the framecounts.txt file
%   headerBug          -- optional. Should be true if recording was made
%                         using MView 3.?.?.?, which writes slightly broken
%                         file headers. Default false.
%
% OUTPUTS
%   framesPerTrial     -- vector of length nTrials. Contains the number of
%                         frames per trial
%   trialNumbers       -- vector of the trial numbers. If values are
%                         negative, this means that the code was damaged
%                         and could not be inferred even with the help of
%                         surrounding trials
%   frame1RelToStartOff -- when the first frame of this trial started,
%                          relative to the offset of the initial TTL on the
%                          startTrial line
%   badAlignments      -- trials that could not be aligned, due to missing
%                         signals or mismatches between signals


%% Parameters

voltageThresh = 1.5;


%% Optional arguments

if ~exist('headerBug', 'var')
  headerBug = 0;
end


%% Read binary file

volt = readMOMAnalog(binFilename, headerBug);

trialCodes = volt(1, :);
slowGalvo = volt(2, :);
trialStart = volt(3, :);


%% Find trial start and end samples

trialStart(trialStart < voltageThresh) = 0;
trialStart(trialStart >= voltageThresh) = 1;
startOnSamples = find(diff(trialStart) == 1) + 1;
if trialStart(1) == 1
  startOnSamples = [1 startOnSamples];
end

startOffSamples = find(diff(trialStart) == -1);

nTrials = length(startOnSamples);


%% Get trial numbers

[trialNumbers, codeTimes] = segmentVoltageAndReadBarcodes(trialCodes);


%% Cross-check start TTLs and trial numbers

repaired = [];
if length(trialNumbers) > nTrials
    error('Farzaneh: you need to check codes below.')
  % If we get here, we lost a trial start (presumably due to a delay in
  % starting the scope). We'll repair it for now so everything lines up,
  % then mark the trial as not aligned at the end.
  diffs = (startOffSamples + 1) - codeTimes(1:length(startOffSamples));
  while length(trialNumbers) > nTrials
    firstBad = find(abs(diffs) > 10, 1);
    repaired(end+1) = firstBad;
    if isempty(firstBad)
      error('framesPerTrialStopStart3An:missingStarts', 'Missing %d trial starts, could not infer where the missing trials were', ...
        length(trialNumbers) - nTrials);
    end
    % Insert placeholder value to make everything else go smoothly, then
    % mark this trial as bad later
    startOnSamples = insertIntoArray(startOnSamples, firstBad, codeTimes(firstBad));
    startOffSamples = insertIntoArray(startOffSamples, firstBad, codeTimes(firstBad));
    nTrials = length(startOffSamples);
  end
  
  fprintf('%d trials were missing trial start TTLs and were repaired, but cannot be aligned\n', length(repaired));
  
elseif length(trialNumbers) < nTrials
    error('framesPerTrialStopStart3An:missingCodes', 'Missing %d entire trial codes', ...
      length(trialNumbers) - nTrials);
end


%% Cross-check start-TTL-off times and code-on times

diffs = (startOffSamples + 1) - codeTimes;

startRotScope_trialCode1_dur = NaN(1, length(codeTimes));
for tr = 1:length(codeTimes) 
    startRotScope_trialCode1_dur(tr) = round(1000*all_data(tr).parsedEvents.states.trialcode1(1) - 1000*all_data(tr).parsedEvents.states.start_rotary_scope(1));
end

badAlignTrStartCode = (isnan(diffs) | abs(startRotScope_trialCode1_dur + diffs) > 1);

% badAlignments = (isnan(diffs) | abs(diffs) > 1);

if any(badAlignTrStartCode)
  warning('%d start-off samples did not line up with code onsets by more than one sample.\n', sum(badAlignTrStartCode));
end

badAlignTrStartCode(repaired) = true;


% %% Debugging
% 
% figure;
% hold on;
% 
% plot(slowGalvo);
% plot(startOnSamples, slowGalvo(startOnSamples), 'r.');
% plot(startOnSamples-1, slowGalvo(startOnSamples-1), 'g.');


%% Use the slow galvo signal to identify frames

trialEndSamples = [startOnSamples(2:end)-1 length(slowGalvo)];
framesPerTrial = cell(1, nTrials);
frame1RelToStartOff = NaN(1, nTrials);
for tr = 1:nTrials
  framesPerTrial{tr} = parseSlowGalvo(slowGalvo(startOnSamples(tr):trialEndSamples(tr)));
  frame1RelToStartOff(tr) = -(startOffSamples(tr) - startOnSamples(tr) + 1);
end


%% If we found any "trial" was actually more than one trial, deal with it
% Sometimes, we see a brief pause in the galvo trace, then it resumes
% without seeing a code or trial start. This might be due to when BControl
% is paused and unpaused. In any case, we need to fix these, because
% otherwise we'll match up trial codes with trials wrong.

multChunks = find(cellfun(@length, framesPerTrial) > 1);
if ~isempty(multChunks)
    warning('Farzaneh: you have not tested this part yet.')
  frame1RelToStartOff = insertIntoArray(frame1RelToStartOff, multChunks, NaN);
  trialNumbers = insertIntoArray(trialNumbers, multChunks, NaN);
%   for m = fliplr(multChunks)
%     if m == 1
%       framesPerTrial = [num2cell(framesPerTrial{m}) framesPerTrial(m+1:end)];
%     elseif m == length(framesPerTrial)
%       framesPerTrial = [framesPerTrial(1:m-1) num2cell(framesPerTrial{m})];
%     else
%       framesPerTrial = [framesPerTrial(1:m-1) num2cell(framesPerTrial{m}) framesPerTrial(m+1:end)];
%     end
%   end
  
  fprintf('%d trial(s) found tacked on to ends of known trials and repaired, but missing alignment info\n', ...
    sum(isnan(frame1RelToStartOff)));
end

framesPerTrial = [framesPerTrial{:}];
framesPerTrial_galvo = framesPerTrial; % Farzaneh

%% If given, parse the frame count file

if exist('framecountFilename', 'var') && ~isempty(framecountFilename)
  framecountFrames = NaN(1, nTrials);
  
  % Open file
  try
    fid = fopen(framecountFilename, 'r');
  catch
    warning('Could not open frame count file %s', framecountFilename);
    return;
  end
  
  % Read each line, keep only the initial number
  line = 0;
  while 1
    line = line + 1;
    oneLine = fgetl(fid);
    if ~ischar(oneLine) || isempty(oneLine)
      break;
    end
    
    tokens = simpleTokenize(oneLine, ' ');
    numStr = tokens{1};
    framecountFrames(line) = str2double(numStr);
  end
  
  if length(framecountFrames) ~= length(framesPerTrial)
     disp('Farzaneh: you may need to change error to warning, bc using the galvo trace for sync is not a good idea anyway.')
     
    error('framesPerTrialStopStart3An:trialCountMismatch', ...
      ['Found %d trials in framecounts.txt, but %d trials in the galvo trace. ' ...
      'Cannot determine which trial has which frame count!'], ...
      length(framecountFrames), length(framesPerTrial));
  end
  
%   % Compare with frame counts from the analog channels
%   figure;
%   hold on;
%   plot(framecountFrames, 'b');
%   plot(framesPerTrial, 'r');
%   
%   figure;
%   plot(framecountFrames - framesPerTrial, 'k');
  
  % Summarize
  fprintf('For reference (not a problem): galvo trace missing %d frames.\n', sum(framecountFrames) - sum(framesPerTrial));
  
else
  warning('No framecounts.txt supplied. Alignment is very likely to drift over trials!');
end



% %% Plot some galvo traces with inferred frames, to see what's up
% 
% samplesPerFrame = 1000 / 30.9;  % Is this value exact?
% 
% trsWrong = find(framecountFrames - framesPerTrial ~= 0, 3);
% 
% trsRight = find(framecountFrames - framesPerTrial == 0, 3);
% 
% % This is all uncorrected for chunk splits!
% for tr = trsWrong
%   figure;
%   hold on;
%   plot(slowGalvo(startOnSamples(tr):trialEndSamples(tr)));
%   for t = 1:framesPerTrial(tr)
%     plot((1 + t * samplesPerFrame) * [1 1], [-3 3], 'r-');
%   end
%   title(sprintf('%d inferred (wrong)', framesPerTrial(tr)));
% end
% 
% for tr = trsRight
%   figure;
%   hold on;
%   plot(slowGalvo(startOnSamples(tr):trialEndSamples(tr)));
%   for t = 1:framesPerTrial(tr)
%     plot((1 + t * samplesPerFrame) * [1 1], [-3 3], 'r-');
%   end
%   title(sprintf('%d inferred (right)', framesPerTrial(tr)));
% end

% %% List the frames where there was disagreement between the galvo signal and framecounts.txt
% % Empirically, there's nothing obviously wrong with these frames.
% 
% cumFrames = cumsum(framecountFrames);
% disagreementTrials = find((framecountFrames - framesPerTrial) ~= 0);
% fprintf('Disagreements between galvo signal and framecounts:\n');
% for d = disagreementTrials
%   fprintf('%d\n', cumFrames(d));
% end



%% Go with framecounts.txt

% framecounts.txt gives the more reliable answer
if exist('framecountFilename', 'var') && ~isempty(framecountFilename)
  framesPerTrial = framecountFrames;
end


%% Mark the repaired trials as not aligned

frame1RelToStartOff(repaired) = NaN;




function nFrames = parseSlowGalvo(galvo)

% First get rid of any initial non-scanning
if galvo(1) == galvo(2) && galvo(1) == galvo(3)
  firstRealValue = find(galvo ~= galvo(1), 1);
  galvo = galvo(firstRealValue:end);
end

% First, look for whether there are breaks in the middle of scanning,
% indicating trials that weren't separated correctly.

chunks = breakScanningChunks(galvo);

samplesPerFrame = 1000 / 30.9;  % Is this value exact?

nFrames = cellfun(@(c) floor(length(c) / samplesPerFrame), chunks);




function chunks = breakScanningChunks(galvo)
% This function looks to see whether scanning stopped in the middle of what
% should be a single trial. If so, break it up.

% This should happen rarely, so it's ok to use a slightly inefficient
% recursive algorithm for convenience.

% To find scan stops, we'll look for 3 consecutive identical values not at
% the end.
runs = (galvo(1:end-2) == galvo(2:end-1) & galvo(1:end-2) == galvo(3:end));
firstRun = find(runs, 1);
lastNonRun = find(runs == 0, 1, 'last');
if isempty(firstRun) || isempty(lastNonRun) || firstRun == lastNonRun + 1
  chunks = {galvo(1:firstRun - 1)};
else
  endOfFirstRun = firstRun + find(runs(firstRun+1:end) == 0, 1);
  chunks = [{galvo(1:firstRun - 1)} breakScanningChunks(galvo(endOfFirstRun:end))];
end
